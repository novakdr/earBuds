'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getKeyForNode = getKeyForNode;

var _fontoxpath = require('fontoxpath');

var fontoxpath = _interopRequireWildcard(_fontoxpath);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var REGISTRY = Symbol('registry');
var NODE = Symbol('node');
var KEY = Symbol('key');
var MODE = Symbol('mode');

var GET_RENDERING_CB = Symbol('rendering callback');
var DEFAULT_MODE = Symbol('default mode');

function getKeyForNode(targetNode) {
	var pieces = [];

	var node = targetNode;

	while (node && node.parentNode) {
		// If any node has an identifier, assume it to be unique and stop traversing up
		if (node.nodeType === 1 && node.hasAttribute('id')) {
			pieces.push(node.getAttribute('id'));
			break;
		}

		pieces.push(Array.prototype.indexOf.call(node.parentNode.childNodes, node));

		node = node.parentNode;
	}

	return pieces.reverse().join('/');
}

/**
 * The rendering API for a specific XML node.
 */

var Renderer = function () {
	function Renderer(registry, mode, node) {
		_classCallCheck(this, Renderer);

		this[REGISTRY] = registry;
		this[MODE] = mode;
		this[NODE] = node;
	}

	/**
  * Returns the XML node for which this renderer was instantiated.
  * @returns {Node}
  */


	_createClass(Renderer, [{
		key: 'getNode',
		value: function getNode() {
			return this[NODE];
		}

		/**
   * Returns a string which is uniquely identifying for the renderer node amongst its siblings. Intended to be used
   * as React's key property.
   * @returns {string}
   */

	}, {
		key: 'key',
		value: function key() {
			if (!this[KEY]) {
				this[KEY] = getKeyForNode(this[NODE]) + (this[MODE] === DEFAULT_MODE ? '' : ':' + this[MODE]);
			}

			return this[KEY];
		}

		/**
   * Returns the rendering of the specific XML node this Renderer is for.
   * @returns {*}
   */

	}, {
		key: 'render',
		value: function render() {
			var registeredContent = this[REGISTRY][GET_RENDERING_CB](this[NODE], this[MODE]);

			for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
				rest[_key] = arguments[_key];
			}

			return registeredContent ? registeredContent.apply(undefined, [this, this[MODE]].concat(rest)) : null;
		}

		/**
   * Returns an array of renderings for a collection of XML nodes, queried relative from the node of this Renderer.
   * @param {string} xPathQuery
   * @returns {Array.<*>}
   */

	}, {
		key: 'traverse',
		value: function traverse(xPathQuery) {
			for (var _len2 = arguments.length, rest = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
				rest[_key2 - 2] = arguments[_key2];
			}

			var _this = this;

			var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[MODE];

			if (!xPathQuery) {
				xPathQuery = './node()';
			}

			// If mode is set to falsy (but not undefined), reset to default mode
			if (!mode) {
				mode = DEFAULT_MODE;
			}

			return fontoxpath.evaluateXPathToNodes(xPathQuery, this[NODE]).map(function (childNode) {
				var _ref;

				return (_ref = new Renderer(_this[REGISTRY], mode, childNode)).render.apply(_ref, rest);
			});
		}
	}]);

	return Renderer;
}();

var Mode = function () {
	function Mode() {
		_classCallCheck(this, Mode);

		this.contentComponents = [];
	}

	/**
  * Register a rendering callback for an XPath test. Any node matching the test (and not a more specific one)
  * will be transformed using onRender.
  * @param xPathTest
  * @param {Mode~onRender} onRender
  */


	_createClass(Mode, [{
		key: 'register',
		value: function register(xPathTest, onRender) {
			this.contentComponents.push({
				xPathTest: xPathTest,
				onRender: onRender
			});

			this.contentComponents = this.contentComponents.sort(function (a, b) {
				return fontoxpath.compareSpecificity(b.xPathTest, a.xPathTest);
			});
		}

		/**
   * Get the rendering callback that best matches a given node.
   * @param node
   * @returns {Registry~onRender}
   */

	}, {
		key: 'get',
		value: function get(node) {
			var contentComponent = this.contentComponents.find(function (contentComponent) {
				return fontoxpath.evaluateXPathToBoolean(contentComponent.xPathTest, node);
			});

			return contentComponent && contentComponent.onRender;
		}

		/**
   * The callback that produces a rendering of the matching node. The callback is passed an instance of
   * {@link Renderer} for that node as first and only argument.
   * @callback Registry~onRender
   * @param {Renderer} renderer
   * @returns {*}
   */

	}]);

	return Mode;
}();

/**
 * Holds the list of xPath tests per rendering callback, and gives you access to the top-level Renderer for a given
 * DOM.
 */


var MODES = Symbol('modes');

var Registry = function () {
	function Registry() {
		_classCallCheck(this, Registry);

		this[MODES] = _defineProperty({}, DEFAULT_MODE, new Mode());
	}

	/**
  * An alias for Mode#register of the default mode.
  * @param {string} xPathTest - For example, `self::section`
  * @param {Mode~onRender} onRender
  */


	_createClass(Registry, [{
		key: 'register',
		value: function register(xPathTest, onRender) {
			return this.mode().register(xPathTest, onRender);
		}

		/**
   * Gives you the Renderer for the top-level node of a given DOM, in a given Mode.
   * @param node
   * @param mode
   * @returns {Renderer}
   */

	}, {
		key: 'node',
		value: function node(_node) {
			var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_MODE;

			return new Renderer(this, mode, _node);
		}

		/**
   * Returns a new or existing Mode of a given name so you can Mode#register something cool on it.
   * @param name
   * @returns {*}
   */

	}, {
		key: 'mode',
		value: function mode() {
			var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODE;

			if (!this[MODES][name]) {
				this[MODES][name] = new Mode();
			}

			return this[MODES][name];
		}
	}, {
		key: 'registerXPathFunction',
		value: function registerXPathFunction(name, signature, returnType, callback) {
			return fontoxpath.registerCustomXPathFunction(name, signature, returnType, callback);
		}
	}, {
		key: GET_RENDERING_CB,
		value: function value(node, mode) {
			if (!this[MODES][mode]) {
				mode = DEFAULT_MODE;
			}

			var renderingCb = this[MODES][mode].get(node);

			if (mode !== DEFAULT_MODE && !renderingCb) {
				return this[GET_RENDERING_CB](node, DEFAULT_MODE);
			}

			return renderingCb;
		}
	}]);

	return Registry;
}();

exports.default = Registry;

